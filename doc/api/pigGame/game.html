<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pigGame.game API documentation</title>
<meta name="description" content="The Game module contains the Game class, which represents a game of Pig â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pigGame.game</code></h1>
</header>
<section id="section-intro">
<p>The Game module contains the Game class, which represents a game of Pig.</p>
<p>The game involves players taking turns rolling a die to accumulate points.
The game can be played in different modes, including Player vs Player (PvP)
and Player vs Computer (PvC).</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The Game module contains the Game class, which represents a game of Pig.

The game involves players taking turns rolling a die to accumulate points.
The game can be played in different modes, including Player vs Player (PvP)
and Player vs Computer (PvC).
&#34;&#34;&#34;

import time
import sys
import cowsay
from termcolor import cprint
from pyfiglet import figlet_format
from colorama import init
from pigGame.score import Score

init(strip=not sys.stdout.isatty())


class Game:
    &#34;&#34;&#34;
    Represent a game of Pig, where players take turns rolling a die.

    The game can be played in different modes: Player vs Player (PvP)
    or Player vs Computer (PvC).

    Attributes:
        players (list of Player): A list containing the two players.
        dice (Dice): An instance of the Dice class representing the game&#39;s die.
        strategy (Intelligence): An instance of the Intelligence class
            representing the computer&#39;s intelligence.
        mode (str): The mode of the game, either &#34;PvP&#34; or &#34;PvC&#34;.
        target_score (int): The target score that players need to reach to win.
        curr_player_index (int): Index of the current player taking turns.
        game_over (bool): Indicates whether the game is over.
    &#34;&#34;&#34;

    def __init__(self, players, dice, strategy, mode):
        &#34;&#34;&#34;
        Initialize a Game object with players, dice, strategy, and game mode.

        Args:
            players (list of Player): A list containing the two players.
            dice (Dice): An instance of the Dice class representing the game&#39;s
                die.
            strategy (Intelligence): An instance of the Intelligence class
                representing the computer&#39;s decision-making process.
            mode (str): The mode of the game, either &#34;PvP&#34; (Player vs Player)
                or &#34;PvC&#34;
                (Player vs Computer).
        &#34;&#34;&#34;
        self.players = players
        self.dice = dice
        self.strategy = strategy
        self.mode = mode
        self.target_score = 100
        self.curr_player_index = 0
        self.round_count = 1
        self.game_over = False
        self.round_finished = True

    def start_game(self):
        &#34;&#34;&#34;
        Begin playing the game and manage the turn flow.

        This method orchestrates the game&#39;s progress, including initiating
        rounds and managing player turns until the game reaches its conclusion.

        During each iteration, it checks if the current round has concluded.
        If so, it displays the round number using a stylized banner, then
        starts the round. It then proceeds to prompt the current player for
        their turn, alternating between players until the game concludes.
        &#34;&#34;&#34;
        while not self.game_over:
            if self.round_finished:
                cprint(
                    figlet_format(f&#34;ROUND {self.round_count}&#34;,
                                  font=&#34;banner3-D&#34;),
                    &#34;green&#34;,
                    &#34;on_black&#34;,
                    attrs=[&#34;bold&#34;],
                )
                self.start_round()
                time.sleep(1)
            if self.curr_player_index == 0:
                cprint(
                    f&#34;{self.players[self.curr_player_index].name}&#39;s turn&#34;,
                    &#34;yellow&#34;,
                    attrs=[&#34;bold&#34;],
                )
            else:
                cprint(
                    f&#34;{self.players[self.curr_player_index].name}&#39;s turn&#34;,
                    &#34;cyan&#34;,
                    attrs=[&#34;bold&#34;],
                )
            self.take_turns()

    def take_turns(self):
        &#34;&#34;&#34;
        Control the turn-taking process for each player.

        This method determines the appropriate action for each player&#39;s turn,
        calling the corresponding round method based on the player type.

        If the current player is a computer, it invokes the &#39;computer_round&#39;
        method to manage the computer&#39;s turn. Otherwise, it calls the
        &#39;player_round&#39; method to handle a human player&#39;s turn.

        &#34;&#34;&#34;
        current_player = self.players[self.curr_player_index]
        if current_player.name == &#34;Computer&#34;:
            self.computer_round(current_player)
        else:
            self.player_round(current_player)

    def computer_round(self, current_player):
        &#34;&#34;&#34;Conducts a round of the game for the computer player.&#34;&#34;&#34;
        round_points = current_player.add_round_points(0)
        if self.strategy.choose_action(round_points) == &#34;roll&#34;:
            self.roll_dice(current_player)
            print(&#34;&#34;)
        else:
            self.hold(current_player)
            print(&#34;&#34;)

    def player_round(self, current_player):
        &#34;&#34;&#34;
        Conducts a round of the game for a human player.

        When it is PvP, two players both using this method.
        &#34;&#34;&#34;
        if self.curr_player_index == 0:
            cprint(
                &#39;&#34;roll&#34;(r), &#34;hold&#34;(h), cheat(c) or &#34;exit&#34;(q)&#39;, &#34;yellow&#34;,
                attrs=[&#34;bold&#34;]
            )
        else:
            cprint(
                &#39;&#34;roll&#34;(r), &#34;hold&#34;(h), cheat(c) or &#34;exit&#34;(q)&#39;, &#34;cyan&#34;,
                attrs=[&#34;bold&#34;]
            )
        decision = input().lower()
        if decision.lower() == &#34;roll&#34; or decision.lower() == &#34;r&#34;:
            self.roll_dice(current_player)
        elif decision.lower() == &#34;hold&#34; or decision.lower() == &#34;h&#34;:
            self.hold(current_player)
        elif decision.lower() == &#34;cheat&#34; or decision.lower() == &#34;c&#34;:
            self.cheat(current_player, 1000)
        elif decision.lower() == &#34;exit&#34; or decision.lower() == &#34;q&#34;:
            cprint(
                cowsay.get_output_string(&#34;cow&#34;, &#34;Feel free to join again!&#34;),
                &#34;green&#34;,
                attrs=[&#34;bold&#34;],
            )
            print(&#34;&#34;)
            self.end_game()
        else:
            cprint(&#34;Invalid decision.&#34;)
            cprint(&#34;Try &#39;roll&#39;, &#39;hold&#39; or &#39;exit&#39;&#34;)
            cprint(&#34;or corresponding short cut: r, h or q.&#34;)
            print(&#34;&#34;)

    def roll_dice(self, player):
        &#34;&#34;&#34;Simulate rolling the die for the player and handles the outcomes.&#34;&#34;&#34;
        if self.curr_player_index == 0:
            cprint(f&#34;{player.name} decided to roll.&#34;, &#34;yellow&#34;, attrs=[&#34;bold&#34;])
        else:
            cprint(f&#34;{player.name} decided to roll.&#34;, &#34;cyan&#34;, attrs=[&#34;bold&#34;])
        time.sleep(1)

        if player.name != &#34;Computer&#34;:
            result = self.dice.player_roll()
        else:
            result = self.dice.computer_roll()

        if result == 1:
            self.roll_result_1(player)
        else:
            self.roll_result_other(player, result)

    def hold(self, player):
        &#34;&#34;&#34;Handle the decision to hold the current player&#39;s turn.&#34;&#34;&#34;
        curr_points = player.current_points(0)
        player.reset_round_points()
        if self.curr_player_index == 0:
            cprint(f&#34;{player.name} decided to hold.&#34;, &#34;yellow&#34;, attrs=[&#34;bold&#34;])
            time.sleep(1)
            cprint(
                f&#34;{player.name} total points: {curr_points}&#34;, &#34;yellow&#34;,
                attrs=[&#34;bold&#34;]
            )
        else:
            cprint(f&#34;{player.name} decided to hold.&#34;, &#34;cyan&#34;, attrs=[&#34;bold&#34;])
            time.sleep(1)
            cprint(f&#34;{player.name} total points: {curr_points}&#34;, &#34;cyan&#34;,
                   attrs=[&#34;bold&#34;])
        print(&#34;&#34;)
        time.sleep(1)
        self.end_round()
        self.end_turn()

    def cheat(self, player, cheat):
        &#34;&#34;&#34;Simulate a cheating move for the player, adding 1000 points.&#34;&#34;&#34;
        cheat_points = player.current_points(cheat)
        if self.curr_player_index == 0:
            cprint(f&#34;{player.name} decided to cheat.&#34;, &#34;yellow&#34;,
                   attrs=[&#34;bold&#34;])
            cprint(
                f&#34;{player.name} got {cheat}. Total points: {cheat_points}&#34;,
                &#34;yellow&#34;,
                attrs=[&#34;bold&#34;],
            )
        else:
            cprint(f&#34;{player.name} decided to cheat.&#34;, &#34;cyan&#34;, attrs=[&#34;bold&#34;])
            cprint(
                f&#34;{player.name} got {cheat}. Total points: {cheat_points}&#34;,
                &#34;cyan&#34;,
                attrs=[&#34;bold&#34;],
            )
        cprint(
            cowsay.get_output_string(&#34;turtle&#34;,
                                     f&#34;Congratulations! {player.name} wins!&#34;),
            &#34;green&#34;,
            attrs=[&#34;bold&#34;],
        )
        print(&#34;&#34;)
        self.high_score_list_checking(player.name, cheat_points)
        self.end_game()

    def roll_result_1(self, player):
        &#34;&#34;&#34;When die gets result 1, this method would be activated.&#34;&#34;&#34;
        if self.curr_player_index == 0:
            cprint(
                f&#34;{player.name} rolled a 1. Your turn is over.&#34;,
                &#34;yellow&#34;,
                attrs=[&#34;bold&#34;],
            )
        else:
            cprint(
                f&#34;{player.name} rolled a 1. Your turn is over.&#34;, &#34;cyan&#34;,
                attrs=[&#34;bold&#34;]
            )
        print(&#34;&#34;)
        time.sleep(1)
        player.current_points_adjust()
        player.reset_round_points()
        self.end_round()
        self.end_turn()

    def roll_result_other(self, player, result):
        &#34;&#34;&#34;When die gets other results than 1, this method would activate.&#34;&#34;&#34;
        player.add_round_points(result)
        curr_points = player.current_points(result)
        if self.curr_player_index == 0:
            cprint(f&#34;{player.name} got {result}.&#34;, &#34;yellow&#34;, attrs=[&#34;bold&#34;])
            time.sleep(1)
            cprint(f&#34;Total points: {curr_points}&#34;, &#34;yellow&#34;, attrs=[&#34;bold&#34;])
        else:
            cprint(f&#34;{player.name} got {result}.&#34;, &#34;cyan&#34;, attrs=[&#34;bold&#34;])
            time.sleep(1)
            cprint(f&#34;Total points: {curr_points}&#34;, &#34;cyan&#34;, attrs=[&#34;bold&#34;])
        print(&#34;&#34;)
        time.sleep(1)
        if curr_points &gt;= self.target_score:
            cprint(
                cowsay.get_output_string(
                    &#34;turtle&#34;, f&#34;Congratulations! {player.name} wins!&#34;
                ),
                &#34;green&#34;,
                attrs=[&#34;bold&#34;],
            )
            print(&#34;&#34;)
            self.high_score_list_checking(player.name, curr_points)
            self.end_game()

    def high_score_list_checking(self, name, points):
        &#34;&#34;&#34;Update the high score list based on the game mode and player.&#34;&#34;&#34;
        score = Score()
        if self.mode == &#34;PvC&#34; and name != &#34;Computer&#34;:
            score.pvc_new_record(name, points)
        elif self.mode == &#34;PvP&#34;:
            score.pvp_new_record(name, points)

    def end_game(self):
        &#34;&#34;&#34;End the game.&#34;&#34;&#34;
        self.game_over = True

    def end_turn(self):
        &#34;&#34;&#34;End the current player&#39;s turn and switches to the next player.&#34;&#34;&#34;
        self.curr_player_index = (self.curr_player_index + 1) % 2

    def start_round(self):
        &#34;&#34;&#34;Start a round.&#34;&#34;&#34;
        self.round_finished = False

    def end_round(self):
        &#34;&#34;&#34;End the round after all the players finished.&#34;&#34;&#34;
        if self.curr_player_index == 1:
            self.round_finished = True
            self.round_count += 1</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pigGame.game.Game"><code class="flex name class">
<span>class <span class="ident">Game</span></span>
<span>(</span><span>players, dice, strategy, mode)</span>
</code></dt>
<dd>
<div class="desc"><p>Represent a game of Pig, where players take turns rolling a die.</p>
<p>The game can be played in different modes: Player vs Player (PvP)
or Player vs Computer (PvC).</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>players</code></strong> :&ensp;<code>list</code> of <code>Player</code></dt>
<dd>A list containing the two players.</dd>
<dt><strong><code>dice</code></strong> :&ensp;<code>Dice</code></dt>
<dd>An instance of the Dice class representing the game's die.</dd>
<dt><strong><code>strategy</code></strong> :&ensp;<code>Intelligence</code></dt>
<dd>An instance of the Intelligence class
representing the computer's intelligence.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>The mode of the game, either "PvP" or "PvC".</dd>
<dt><strong><code>target_score</code></strong> :&ensp;<code>int</code></dt>
<dd>The target score that players need to reach to win.</dd>
<dt><strong><code>curr_player_index</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the current player taking turns.</dd>
<dt><strong><code>game_over</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether the game is over.</dd>
</dl>
<p>Initialize a Game object with players, dice, strategy, and game mode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>players</code></strong> :&ensp;<code>list</code> of <code>Player</code></dt>
<dd>A list containing the two players.</dd>
<dt><strong><code>dice</code></strong> :&ensp;<code>Dice</code></dt>
<dd>An instance of the Dice class representing the game's
die.</dd>
<dt><strong><code>strategy</code></strong> :&ensp;<code>Intelligence</code></dt>
<dd>An instance of the Intelligence class
representing the computer's decision-making process.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>The mode of the game, either "PvP" (Player vs Player)
or "PvC"
(Player vs Computer).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Game:
    &#34;&#34;&#34;
    Represent a game of Pig, where players take turns rolling a die.

    The game can be played in different modes: Player vs Player (PvP)
    or Player vs Computer (PvC).

    Attributes:
        players (list of Player): A list containing the two players.
        dice (Dice): An instance of the Dice class representing the game&#39;s die.
        strategy (Intelligence): An instance of the Intelligence class
            representing the computer&#39;s intelligence.
        mode (str): The mode of the game, either &#34;PvP&#34; or &#34;PvC&#34;.
        target_score (int): The target score that players need to reach to win.
        curr_player_index (int): Index of the current player taking turns.
        game_over (bool): Indicates whether the game is over.
    &#34;&#34;&#34;

    def __init__(self, players, dice, strategy, mode):
        &#34;&#34;&#34;
        Initialize a Game object with players, dice, strategy, and game mode.

        Args:
            players (list of Player): A list containing the two players.
            dice (Dice): An instance of the Dice class representing the game&#39;s
                die.
            strategy (Intelligence): An instance of the Intelligence class
                representing the computer&#39;s decision-making process.
            mode (str): The mode of the game, either &#34;PvP&#34; (Player vs Player)
                or &#34;PvC&#34;
                (Player vs Computer).
        &#34;&#34;&#34;
        self.players = players
        self.dice = dice
        self.strategy = strategy
        self.mode = mode
        self.target_score = 100
        self.curr_player_index = 0
        self.round_count = 1
        self.game_over = False
        self.round_finished = True

    def start_game(self):
        &#34;&#34;&#34;
        Begin playing the game and manage the turn flow.

        This method orchestrates the game&#39;s progress, including initiating
        rounds and managing player turns until the game reaches its conclusion.

        During each iteration, it checks if the current round has concluded.
        If so, it displays the round number using a stylized banner, then
        starts the round. It then proceeds to prompt the current player for
        their turn, alternating between players until the game concludes.
        &#34;&#34;&#34;
        while not self.game_over:
            if self.round_finished:
                cprint(
                    figlet_format(f&#34;ROUND {self.round_count}&#34;,
                                  font=&#34;banner3-D&#34;),
                    &#34;green&#34;,
                    &#34;on_black&#34;,
                    attrs=[&#34;bold&#34;],
                )
                self.start_round()
                time.sleep(1)
            if self.curr_player_index == 0:
                cprint(
                    f&#34;{self.players[self.curr_player_index].name}&#39;s turn&#34;,
                    &#34;yellow&#34;,
                    attrs=[&#34;bold&#34;],
                )
            else:
                cprint(
                    f&#34;{self.players[self.curr_player_index].name}&#39;s turn&#34;,
                    &#34;cyan&#34;,
                    attrs=[&#34;bold&#34;],
                )
            self.take_turns()

    def take_turns(self):
        &#34;&#34;&#34;
        Control the turn-taking process for each player.

        This method determines the appropriate action for each player&#39;s turn,
        calling the corresponding round method based on the player type.

        If the current player is a computer, it invokes the &#39;computer_round&#39;
        method to manage the computer&#39;s turn. Otherwise, it calls the
        &#39;player_round&#39; method to handle a human player&#39;s turn.

        &#34;&#34;&#34;
        current_player = self.players[self.curr_player_index]
        if current_player.name == &#34;Computer&#34;:
            self.computer_round(current_player)
        else:
            self.player_round(current_player)

    def computer_round(self, current_player):
        &#34;&#34;&#34;Conducts a round of the game for the computer player.&#34;&#34;&#34;
        round_points = current_player.add_round_points(0)
        if self.strategy.choose_action(round_points) == &#34;roll&#34;:
            self.roll_dice(current_player)
            print(&#34;&#34;)
        else:
            self.hold(current_player)
            print(&#34;&#34;)

    def player_round(self, current_player):
        &#34;&#34;&#34;
        Conducts a round of the game for a human player.

        When it is PvP, two players both using this method.
        &#34;&#34;&#34;
        if self.curr_player_index == 0:
            cprint(
                &#39;&#34;roll&#34;(r), &#34;hold&#34;(h), cheat(c) or &#34;exit&#34;(q)&#39;, &#34;yellow&#34;,
                attrs=[&#34;bold&#34;]
            )
        else:
            cprint(
                &#39;&#34;roll&#34;(r), &#34;hold&#34;(h), cheat(c) or &#34;exit&#34;(q)&#39;, &#34;cyan&#34;,
                attrs=[&#34;bold&#34;]
            )
        decision = input().lower()
        if decision.lower() == &#34;roll&#34; or decision.lower() == &#34;r&#34;:
            self.roll_dice(current_player)
        elif decision.lower() == &#34;hold&#34; or decision.lower() == &#34;h&#34;:
            self.hold(current_player)
        elif decision.lower() == &#34;cheat&#34; or decision.lower() == &#34;c&#34;:
            self.cheat(current_player, 1000)
        elif decision.lower() == &#34;exit&#34; or decision.lower() == &#34;q&#34;:
            cprint(
                cowsay.get_output_string(&#34;cow&#34;, &#34;Feel free to join again!&#34;),
                &#34;green&#34;,
                attrs=[&#34;bold&#34;],
            )
            print(&#34;&#34;)
            self.end_game()
        else:
            cprint(&#34;Invalid decision.&#34;)
            cprint(&#34;Try &#39;roll&#39;, &#39;hold&#39; or &#39;exit&#39;&#34;)
            cprint(&#34;or corresponding short cut: r, h or q.&#34;)
            print(&#34;&#34;)

    def roll_dice(self, player):
        &#34;&#34;&#34;Simulate rolling the die for the player and handles the outcomes.&#34;&#34;&#34;
        if self.curr_player_index == 0:
            cprint(f&#34;{player.name} decided to roll.&#34;, &#34;yellow&#34;, attrs=[&#34;bold&#34;])
        else:
            cprint(f&#34;{player.name} decided to roll.&#34;, &#34;cyan&#34;, attrs=[&#34;bold&#34;])
        time.sleep(1)

        if player.name != &#34;Computer&#34;:
            result = self.dice.player_roll()
        else:
            result = self.dice.computer_roll()

        if result == 1:
            self.roll_result_1(player)
        else:
            self.roll_result_other(player, result)

    def hold(self, player):
        &#34;&#34;&#34;Handle the decision to hold the current player&#39;s turn.&#34;&#34;&#34;
        curr_points = player.current_points(0)
        player.reset_round_points()
        if self.curr_player_index == 0:
            cprint(f&#34;{player.name} decided to hold.&#34;, &#34;yellow&#34;, attrs=[&#34;bold&#34;])
            time.sleep(1)
            cprint(
                f&#34;{player.name} total points: {curr_points}&#34;, &#34;yellow&#34;,
                attrs=[&#34;bold&#34;]
            )
        else:
            cprint(f&#34;{player.name} decided to hold.&#34;, &#34;cyan&#34;, attrs=[&#34;bold&#34;])
            time.sleep(1)
            cprint(f&#34;{player.name} total points: {curr_points}&#34;, &#34;cyan&#34;,
                   attrs=[&#34;bold&#34;])
        print(&#34;&#34;)
        time.sleep(1)
        self.end_round()
        self.end_turn()

    def cheat(self, player, cheat):
        &#34;&#34;&#34;Simulate a cheating move for the player, adding 1000 points.&#34;&#34;&#34;
        cheat_points = player.current_points(cheat)
        if self.curr_player_index == 0:
            cprint(f&#34;{player.name} decided to cheat.&#34;, &#34;yellow&#34;,
                   attrs=[&#34;bold&#34;])
            cprint(
                f&#34;{player.name} got {cheat}. Total points: {cheat_points}&#34;,
                &#34;yellow&#34;,
                attrs=[&#34;bold&#34;],
            )
        else:
            cprint(f&#34;{player.name} decided to cheat.&#34;, &#34;cyan&#34;, attrs=[&#34;bold&#34;])
            cprint(
                f&#34;{player.name} got {cheat}. Total points: {cheat_points}&#34;,
                &#34;cyan&#34;,
                attrs=[&#34;bold&#34;],
            )
        cprint(
            cowsay.get_output_string(&#34;turtle&#34;,
                                     f&#34;Congratulations! {player.name} wins!&#34;),
            &#34;green&#34;,
            attrs=[&#34;bold&#34;],
        )
        print(&#34;&#34;)
        self.high_score_list_checking(player.name, cheat_points)
        self.end_game()

    def roll_result_1(self, player):
        &#34;&#34;&#34;When die gets result 1, this method would be activated.&#34;&#34;&#34;
        if self.curr_player_index == 0:
            cprint(
                f&#34;{player.name} rolled a 1. Your turn is over.&#34;,
                &#34;yellow&#34;,
                attrs=[&#34;bold&#34;],
            )
        else:
            cprint(
                f&#34;{player.name} rolled a 1. Your turn is over.&#34;, &#34;cyan&#34;,
                attrs=[&#34;bold&#34;]
            )
        print(&#34;&#34;)
        time.sleep(1)
        player.current_points_adjust()
        player.reset_round_points()
        self.end_round()
        self.end_turn()

    def roll_result_other(self, player, result):
        &#34;&#34;&#34;When die gets other results than 1, this method would activate.&#34;&#34;&#34;
        player.add_round_points(result)
        curr_points = player.current_points(result)
        if self.curr_player_index == 0:
            cprint(f&#34;{player.name} got {result}.&#34;, &#34;yellow&#34;, attrs=[&#34;bold&#34;])
            time.sleep(1)
            cprint(f&#34;Total points: {curr_points}&#34;, &#34;yellow&#34;, attrs=[&#34;bold&#34;])
        else:
            cprint(f&#34;{player.name} got {result}.&#34;, &#34;cyan&#34;, attrs=[&#34;bold&#34;])
            time.sleep(1)
            cprint(f&#34;Total points: {curr_points}&#34;, &#34;cyan&#34;, attrs=[&#34;bold&#34;])
        print(&#34;&#34;)
        time.sleep(1)
        if curr_points &gt;= self.target_score:
            cprint(
                cowsay.get_output_string(
                    &#34;turtle&#34;, f&#34;Congratulations! {player.name} wins!&#34;
                ),
                &#34;green&#34;,
                attrs=[&#34;bold&#34;],
            )
            print(&#34;&#34;)
            self.high_score_list_checking(player.name, curr_points)
            self.end_game()

    def high_score_list_checking(self, name, points):
        &#34;&#34;&#34;Update the high score list based on the game mode and player.&#34;&#34;&#34;
        score = Score()
        if self.mode == &#34;PvC&#34; and name != &#34;Computer&#34;:
            score.pvc_new_record(name, points)
        elif self.mode == &#34;PvP&#34;:
            score.pvp_new_record(name, points)

    def end_game(self):
        &#34;&#34;&#34;End the game.&#34;&#34;&#34;
        self.game_over = True

    def end_turn(self):
        &#34;&#34;&#34;End the current player&#39;s turn and switches to the next player.&#34;&#34;&#34;
        self.curr_player_index = (self.curr_player_index + 1) % 2

    def start_round(self):
        &#34;&#34;&#34;Start a round.&#34;&#34;&#34;
        self.round_finished = False

    def end_round(self):
        &#34;&#34;&#34;End the round after all the players finished.&#34;&#34;&#34;
        if self.curr_player_index == 1:
            self.round_finished = True
            self.round_count += 1</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pigGame.game.Game.cheat"><code class="name flex">
<span>def <span class="ident">cheat</span></span>(<span>self, player, cheat)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate a cheating move for the player, adding 1000 points.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cheat(self, player, cheat):
    &#34;&#34;&#34;Simulate a cheating move for the player, adding 1000 points.&#34;&#34;&#34;
    cheat_points = player.current_points(cheat)
    if self.curr_player_index == 0:
        cprint(f&#34;{player.name} decided to cheat.&#34;, &#34;yellow&#34;,
               attrs=[&#34;bold&#34;])
        cprint(
            f&#34;{player.name} got {cheat}. Total points: {cheat_points}&#34;,
            &#34;yellow&#34;,
            attrs=[&#34;bold&#34;],
        )
    else:
        cprint(f&#34;{player.name} decided to cheat.&#34;, &#34;cyan&#34;, attrs=[&#34;bold&#34;])
        cprint(
            f&#34;{player.name} got {cheat}. Total points: {cheat_points}&#34;,
            &#34;cyan&#34;,
            attrs=[&#34;bold&#34;],
        )
    cprint(
        cowsay.get_output_string(&#34;turtle&#34;,
                                 f&#34;Congratulations! {player.name} wins!&#34;),
        &#34;green&#34;,
        attrs=[&#34;bold&#34;],
    )
    print(&#34;&#34;)
    self.high_score_list_checking(player.name, cheat_points)
    self.end_game()</code></pre>
</details>
</dd>
<dt id="pigGame.game.Game.computer_round"><code class="name flex">
<span>def <span class="ident">computer_round</span></span>(<span>self, current_player)</span>
</code></dt>
<dd>
<div class="desc"><p>Conducts a round of the game for the computer player.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def computer_round(self, current_player):
    &#34;&#34;&#34;Conducts a round of the game for the computer player.&#34;&#34;&#34;
    round_points = current_player.add_round_points(0)
    if self.strategy.choose_action(round_points) == &#34;roll&#34;:
        self.roll_dice(current_player)
        print(&#34;&#34;)
    else:
        self.hold(current_player)
        print(&#34;&#34;)</code></pre>
</details>
</dd>
<dt id="pigGame.game.Game.end_game"><code class="name flex">
<span>def <span class="ident">end_game</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>End the game.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_game(self):
    &#34;&#34;&#34;End the game.&#34;&#34;&#34;
    self.game_over = True</code></pre>
</details>
</dd>
<dt id="pigGame.game.Game.end_round"><code class="name flex">
<span>def <span class="ident">end_round</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>End the round after all the players finished.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_round(self):
    &#34;&#34;&#34;End the round after all the players finished.&#34;&#34;&#34;
    if self.curr_player_index == 1:
        self.round_finished = True
        self.round_count += 1</code></pre>
</details>
</dd>
<dt id="pigGame.game.Game.end_turn"><code class="name flex">
<span>def <span class="ident">end_turn</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>End the current player's turn and switches to the next player.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_turn(self):
    &#34;&#34;&#34;End the current player&#39;s turn and switches to the next player.&#34;&#34;&#34;
    self.curr_player_index = (self.curr_player_index + 1) % 2</code></pre>
</details>
</dd>
<dt id="pigGame.game.Game.high_score_list_checking"><code class="name flex">
<span>def <span class="ident">high_score_list_checking</span></span>(<span>self, name, points)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the high score list based on the game mode and player.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def high_score_list_checking(self, name, points):
    &#34;&#34;&#34;Update the high score list based on the game mode and player.&#34;&#34;&#34;
    score = Score()
    if self.mode == &#34;PvC&#34; and name != &#34;Computer&#34;:
        score.pvc_new_record(name, points)
    elif self.mode == &#34;PvP&#34;:
        score.pvp_new_record(name, points)</code></pre>
</details>
</dd>
<dt id="pigGame.game.Game.hold"><code class="name flex">
<span>def <span class="ident">hold</span></span>(<span>self, player)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle the decision to hold the current player's turn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hold(self, player):
    &#34;&#34;&#34;Handle the decision to hold the current player&#39;s turn.&#34;&#34;&#34;
    curr_points = player.current_points(0)
    player.reset_round_points()
    if self.curr_player_index == 0:
        cprint(f&#34;{player.name} decided to hold.&#34;, &#34;yellow&#34;, attrs=[&#34;bold&#34;])
        time.sleep(1)
        cprint(
            f&#34;{player.name} total points: {curr_points}&#34;, &#34;yellow&#34;,
            attrs=[&#34;bold&#34;]
        )
    else:
        cprint(f&#34;{player.name} decided to hold.&#34;, &#34;cyan&#34;, attrs=[&#34;bold&#34;])
        time.sleep(1)
        cprint(f&#34;{player.name} total points: {curr_points}&#34;, &#34;cyan&#34;,
               attrs=[&#34;bold&#34;])
    print(&#34;&#34;)
    time.sleep(1)
    self.end_round()
    self.end_turn()</code></pre>
</details>
</dd>
<dt id="pigGame.game.Game.player_round"><code class="name flex">
<span>def <span class="ident">player_round</span></span>(<span>self, current_player)</span>
</code></dt>
<dd>
<div class="desc"><p>Conducts a round of the game for a human player.</p>
<p>When it is PvP, two players both using this method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def player_round(self, current_player):
    &#34;&#34;&#34;
    Conducts a round of the game for a human player.

    When it is PvP, two players both using this method.
    &#34;&#34;&#34;
    if self.curr_player_index == 0:
        cprint(
            &#39;&#34;roll&#34;(r), &#34;hold&#34;(h), cheat(c) or &#34;exit&#34;(q)&#39;, &#34;yellow&#34;,
            attrs=[&#34;bold&#34;]
        )
    else:
        cprint(
            &#39;&#34;roll&#34;(r), &#34;hold&#34;(h), cheat(c) or &#34;exit&#34;(q)&#39;, &#34;cyan&#34;,
            attrs=[&#34;bold&#34;]
        )
    decision = input().lower()
    if decision.lower() == &#34;roll&#34; or decision.lower() == &#34;r&#34;:
        self.roll_dice(current_player)
    elif decision.lower() == &#34;hold&#34; or decision.lower() == &#34;h&#34;:
        self.hold(current_player)
    elif decision.lower() == &#34;cheat&#34; or decision.lower() == &#34;c&#34;:
        self.cheat(current_player, 1000)
    elif decision.lower() == &#34;exit&#34; or decision.lower() == &#34;q&#34;:
        cprint(
            cowsay.get_output_string(&#34;cow&#34;, &#34;Feel free to join again!&#34;),
            &#34;green&#34;,
            attrs=[&#34;bold&#34;],
        )
        print(&#34;&#34;)
        self.end_game()
    else:
        cprint(&#34;Invalid decision.&#34;)
        cprint(&#34;Try &#39;roll&#39;, &#39;hold&#39; or &#39;exit&#39;&#34;)
        cprint(&#34;or corresponding short cut: r, h or q.&#34;)
        print(&#34;&#34;)</code></pre>
</details>
</dd>
<dt id="pigGame.game.Game.roll_dice"><code class="name flex">
<span>def <span class="ident">roll_dice</span></span>(<span>self, player)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate rolling the die for the player and handles the outcomes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def roll_dice(self, player):
    &#34;&#34;&#34;Simulate rolling the die for the player and handles the outcomes.&#34;&#34;&#34;
    if self.curr_player_index == 0:
        cprint(f&#34;{player.name} decided to roll.&#34;, &#34;yellow&#34;, attrs=[&#34;bold&#34;])
    else:
        cprint(f&#34;{player.name} decided to roll.&#34;, &#34;cyan&#34;, attrs=[&#34;bold&#34;])
    time.sleep(1)

    if player.name != &#34;Computer&#34;:
        result = self.dice.player_roll()
    else:
        result = self.dice.computer_roll()

    if result == 1:
        self.roll_result_1(player)
    else:
        self.roll_result_other(player, result)</code></pre>
</details>
</dd>
<dt id="pigGame.game.Game.roll_result_1"><code class="name flex">
<span>def <span class="ident">roll_result_1</span></span>(<span>self, player)</span>
</code></dt>
<dd>
<div class="desc"><p>When die gets result 1, this method would be activated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def roll_result_1(self, player):
    &#34;&#34;&#34;When die gets result 1, this method would be activated.&#34;&#34;&#34;
    if self.curr_player_index == 0:
        cprint(
            f&#34;{player.name} rolled a 1. Your turn is over.&#34;,
            &#34;yellow&#34;,
            attrs=[&#34;bold&#34;],
        )
    else:
        cprint(
            f&#34;{player.name} rolled a 1. Your turn is over.&#34;, &#34;cyan&#34;,
            attrs=[&#34;bold&#34;]
        )
    print(&#34;&#34;)
    time.sleep(1)
    player.current_points_adjust()
    player.reset_round_points()
    self.end_round()
    self.end_turn()</code></pre>
</details>
</dd>
<dt id="pigGame.game.Game.roll_result_other"><code class="name flex">
<span>def <span class="ident">roll_result_other</span></span>(<span>self, player, result)</span>
</code></dt>
<dd>
<div class="desc"><p>When die gets other results than 1, this method would activate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def roll_result_other(self, player, result):
    &#34;&#34;&#34;When die gets other results than 1, this method would activate.&#34;&#34;&#34;
    player.add_round_points(result)
    curr_points = player.current_points(result)
    if self.curr_player_index == 0:
        cprint(f&#34;{player.name} got {result}.&#34;, &#34;yellow&#34;, attrs=[&#34;bold&#34;])
        time.sleep(1)
        cprint(f&#34;Total points: {curr_points}&#34;, &#34;yellow&#34;, attrs=[&#34;bold&#34;])
    else:
        cprint(f&#34;{player.name} got {result}.&#34;, &#34;cyan&#34;, attrs=[&#34;bold&#34;])
        time.sleep(1)
        cprint(f&#34;Total points: {curr_points}&#34;, &#34;cyan&#34;, attrs=[&#34;bold&#34;])
    print(&#34;&#34;)
    time.sleep(1)
    if curr_points &gt;= self.target_score:
        cprint(
            cowsay.get_output_string(
                &#34;turtle&#34;, f&#34;Congratulations! {player.name} wins!&#34;
            ),
            &#34;green&#34;,
            attrs=[&#34;bold&#34;],
        )
        print(&#34;&#34;)
        self.high_score_list_checking(player.name, curr_points)
        self.end_game()</code></pre>
</details>
</dd>
<dt id="pigGame.game.Game.start_game"><code class="name flex">
<span>def <span class="ident">start_game</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Begin playing the game and manage the turn flow.</p>
<p>This method orchestrates the game's progress, including initiating
rounds and managing player turns until the game reaches its conclusion.</p>
<p>During each iteration, it checks if the current round has concluded.
If so, it displays the round number using a stylized banner, then
starts the round. It then proceeds to prompt the current player for
their turn, alternating between players until the game concludes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_game(self):
    &#34;&#34;&#34;
    Begin playing the game and manage the turn flow.

    This method orchestrates the game&#39;s progress, including initiating
    rounds and managing player turns until the game reaches its conclusion.

    During each iteration, it checks if the current round has concluded.
    If so, it displays the round number using a stylized banner, then
    starts the round. It then proceeds to prompt the current player for
    their turn, alternating between players until the game concludes.
    &#34;&#34;&#34;
    while not self.game_over:
        if self.round_finished:
            cprint(
                figlet_format(f&#34;ROUND {self.round_count}&#34;,
                              font=&#34;banner3-D&#34;),
                &#34;green&#34;,
                &#34;on_black&#34;,
                attrs=[&#34;bold&#34;],
            )
            self.start_round()
            time.sleep(1)
        if self.curr_player_index == 0:
            cprint(
                f&#34;{self.players[self.curr_player_index].name}&#39;s turn&#34;,
                &#34;yellow&#34;,
                attrs=[&#34;bold&#34;],
            )
        else:
            cprint(
                f&#34;{self.players[self.curr_player_index].name}&#39;s turn&#34;,
                &#34;cyan&#34;,
                attrs=[&#34;bold&#34;],
            )
        self.take_turns()</code></pre>
</details>
</dd>
<dt id="pigGame.game.Game.start_round"><code class="name flex">
<span>def <span class="ident">start_round</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start a round.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_round(self):
    &#34;&#34;&#34;Start a round.&#34;&#34;&#34;
    self.round_finished = False</code></pre>
</details>
</dd>
<dt id="pigGame.game.Game.take_turns"><code class="name flex">
<span>def <span class="ident">take_turns</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Control the turn-taking process for each player.</p>
<p>This method determines the appropriate action for each player's turn,
calling the corresponding round method based on the player type.</p>
<p>If the current player is a computer, it invokes the 'computer_round'
method to manage the computer's turn. Otherwise, it calls the
'player_round' method to handle a human player's turn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take_turns(self):
    &#34;&#34;&#34;
    Control the turn-taking process for each player.

    This method determines the appropriate action for each player&#39;s turn,
    calling the corresponding round method based on the player type.

    If the current player is a computer, it invokes the &#39;computer_round&#39;
    method to manage the computer&#39;s turn. Otherwise, it calls the
    &#39;player_round&#39; method to handle a human player&#39;s turn.

    &#34;&#34;&#34;
    current_player = self.players[self.curr_player_index]
    if current_player.name == &#34;Computer&#34;:
        self.computer_round(current_player)
    else:
        self.player_round(current_player)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pigGame" href="index.html">pigGame</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pigGame.game.Game" href="#pigGame.game.Game">Game</a></code></h4>
<ul class="">
<li><code><a title="pigGame.game.Game.cheat" href="#pigGame.game.Game.cheat">cheat</a></code></li>
<li><code><a title="pigGame.game.Game.computer_round" href="#pigGame.game.Game.computer_round">computer_round</a></code></li>
<li><code><a title="pigGame.game.Game.end_game" href="#pigGame.game.Game.end_game">end_game</a></code></li>
<li><code><a title="pigGame.game.Game.end_round" href="#pigGame.game.Game.end_round">end_round</a></code></li>
<li><code><a title="pigGame.game.Game.end_turn" href="#pigGame.game.Game.end_turn">end_turn</a></code></li>
<li><code><a title="pigGame.game.Game.high_score_list_checking" href="#pigGame.game.Game.high_score_list_checking">high_score_list_checking</a></code></li>
<li><code><a title="pigGame.game.Game.hold" href="#pigGame.game.Game.hold">hold</a></code></li>
<li><code><a title="pigGame.game.Game.player_round" href="#pigGame.game.Game.player_round">player_round</a></code></li>
<li><code><a title="pigGame.game.Game.roll_dice" href="#pigGame.game.Game.roll_dice">roll_dice</a></code></li>
<li><code><a title="pigGame.game.Game.roll_result_1" href="#pigGame.game.Game.roll_result_1">roll_result_1</a></code></li>
<li><code><a title="pigGame.game.Game.roll_result_other" href="#pigGame.game.Game.roll_result_other">roll_result_other</a></code></li>
<li><code><a title="pigGame.game.Game.start_game" href="#pigGame.game.Game.start_game">start_game</a></code></li>
<li><code><a title="pigGame.game.Game.start_round" href="#pigGame.game.Game.start_round">start_round</a></code></li>
<li><code><a title="pigGame.game.Game.take_turns" href="#pigGame.game.Game.take_turns">take_turns</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>